ac.coord=tmp$ac.coord
accept1$coord=accept1$coord+tmp$accept
# ac.coord=ac.coord.true
#sample phi
tmp=sample.phi(ac.coord=ac.coord,grid.coord=grid.coord,n.grid=n.grid,
n.ac=n.ac,phi=phi,jump=jump1$phi,dat=dat,z=z)
phi=tmp$phi
accept1$phi=accept1$phi+tmp$accept
# phi=phi.true
#sample z
z=sample.z(ac.coord=ac.coord,grid.coord=grid.coord,
n.grid=n.grid,n.ac=n.ac,n.tsegm=n.tsegm,dat=dat)
# z=z.true
#adapt MH
if (i<nburn & i%%adaptMH==0){
tmp=print.adapt(accept1z=accept1,jump1z=jump1,accept.output=adaptMH)
jump1=tmp$jump1
accept1=tmp$accept1
}
#store results
store.coord[i,]=unlist(ac.coord)
store.z[i,]=z
store.param[i,]=phi
}
plot(store.param,type='l')
ordem=c(1,3,2)
ac.coord[ordem,]
rm(list=ls(all=TRUE))
set.seed(10)
setwd('U:\\GIT_models\\activity_center1')
library('Rcpp')
sourceCpp('aux1.cpp')
source('gibbs sampler.R')
source('gibbs functions.R')
rm(list=ls(all=TRUE))
set.seed(10)
#read important functions
setwd('U:\\GIT_models\\activity_center1')
library('Rcpp')
sourceCpp('aux1.cpp')
source('gibbs sampler.R')
source('gibbs functions.R')
#get data
dat=read.csv('fake data.csv',as.is=T)
grid.coord=read.csv('fake data grid.csv',as.is=T)
#basic setup
ngibbs=1000
nburn=ngibbs/2
#run gibbs sampler
res=gibbs.activity.center(dat=dat,grid.coord=grid.coord,n.ac=3,
ac.coord.init=data.frame(x=runif(n.ac),y=runif(n.ac)))
rm(list=ls(all=TRUE))
set.seed(10)
#read important functions
setwd('U:\\GIT_models\\activity_center1')
library('Rcpp')
sourceCpp('aux1.cpp')
source('gibbs sampler.R')
source('gibbs functions.R')
#get data
dat=read.csv('fake data.csv',as.is=T)
grid.coord=read.csv('fake data grid.csv',as.is=T)
#basic setup
ngibbs=1000
nburn=ngibbs/2
n.ac=3
#run gibbs sampler
res=gibbs.activity.center(dat=dat,grid.coord=grid.coord,n.ac=n.ac,
ac.coord.init=data.frame(x=runif(n.ac),y=runif(n.ac)))
rm(list=ls(all=TRUE))
set.seed(10)
#read important functions
setwd('U:\\GIT_models\\activity_center1')
library('Rcpp')
sourceCpp('aux1.cpp')
source('gibbs sampler.R')
source('gibbs functions.R')
#get data
dat=read.csv('fake data.csv',as.is=T)
grid.coord=read.csv('fake data grid.csv',as.is=T)
#basic setup
ngibbs=1000
nburn=ngibbs/2
n.ac=3
#run gibbs sampler
res=gibbs.activity.center(dat=dat,grid.coord=grid.coord,n.ac=n.ac,
ac.coord.init=data.frame(x=runif(n.ac),y=runif(n.ac)))
rm(list=ls(all=TRUE))
set.seed(10)
#read important functions
setwd('U:\\GIT_models\\activity_center1')
library('Rcpp')
sourceCpp('aux1.cpp')
source('gibbs sampler.R')
source('gibbs functions.R')
#get data
dat=read.csv('fake data.csv',as.is=T)
grid.coord=read.csv('fake data grid.csv',as.is=T)
#basic setup
ngibbs=1000
nburn=ngibbs/2
n.ac=3
#run gibbs sampler
res=gibbs.activity.center(dat=dat,grid.coord=grid.coord,n.ac=n.ac,
ac.coord.init=data.frame(x=runif(n.ac),y=runif(n.ac)))
rm(list=ls(all=TRUE))
set.seed(10)
#read important functions
setwd('U:\\GIT_models\\activity_center1')
library('Rcpp')
sourceCpp('aux1.cpp')
source('gibbs sampler.R')
source('gibbs functions.R')
#get data
dat=read.csv('fake data.csv',as.is=T)
grid.coord=read.csv('fake data grid.csv',as.is=T)
#basic setup
ngibbs=1000
nburn=ngibbs/2
n.ac=3
#run gibbs sampler
res=gibbs.activity.center(dat=dat,grid.coord=grid.coord,n.ac=n.ac,
ac.coord.init=data.frame(x=runif(n.ac),y=runif(n.ac)))
rm(list=ls(all=TRUE))
set.seed(10)
#read important functions
setwd('U:\\GIT_models\\activity_center1')
library('Rcpp')
sourceCpp('aux1.cpp')
source('gibbs sampler.R')
source('gibbs functions.R')
#get data
dat=read.csv('fake data.csv',as.is=T)
grid.coord=read.csv('fake data grid.csv',as.is=T)
#basic setup
ngibbs=1000
nburn=ngibbs/2
n.ac=3
#run gibbs sampler
res=gibbs.activity.center(dat=dat,grid.coord=grid.coord,n.ac=n.ac,
ac.coord.init=data.frame(x=runif(n.ac),y=runif(n.ac)))
rm(list=ls(all=TRUE))
set.seed(10)
#read important functions
setwd('U:\\GIT_models\\activity_center1')
library('Rcpp')
sourceCpp('aux1.cpp')
source('gibbs sampler.R')
source('gibbs functions.R')
#get data
dat=read.csv('fake data.csv',as.is=T)
grid.coord=read.csv('fake data grid.csv',as.is=T)
#basic setup
ngibbs=1000
nburn=ngibbs/2
n.ac=3
#run gibbs sampler
options(warn=2)
res=gibbs.activity.center(dat=dat,grid.coord=grid.coord,n.ac=n.ac,
ac.coord.init=data.frame(x=runif(n.ac),y=runif(n.ac)))
rm(list=ls(all=TRUE))
set.seed(10)
#read important functions
setwd('U:\\GIT_models\\activity_center1')
library('Rcpp')
sourceCpp('aux1.cpp')
source('gibbs sampler.R')
source('gibbs functions.R')
#get data
dat=read.csv('fake data.csv',as.is=T)
grid.coord=read.csv('fake data grid.csv',as.is=T)
#basic setup
ngibbs=1000
nburn=ngibbs/2
n.ac=3
#run gibbs sampler
options(warn=2)
ac.coord.init=data.frame(x=runif(n.ac),y=runif(n.ac))
n.tsegm=nrow(dat)
n.grid=nrow(grid.coord)
#initial values
ac.coord=ac.coord.init
#cluster membership
z=sample(1:n.ac,size=n.tsegm,replace=T)
#distance decay parameter
phi=0.0001
#matrices to store results
store.coord=matrix(NA,ngibbs,n.ac*2)
store.z=matrix(NA,ngibbs,n.tsegm)
store.param=matrix(NA,ngibbs,1) #to store phi
#MH stuff
adaptMH=50
jump1=list(coord=matrix(10,n.ac,2),phi=0.2)
accept1=list(coord=matrix(0,n.ac,2),phi=0)
#gibbs sampler
for (i in 1:ngibbs){
print(i)
#sample coordinates
tmp=sample.coord(ac.coord=ac.coord,jump=jump1$coord,dat=dat,
grid.coord=grid.coord,z=z,n.ac=n.ac,n.grid=n.grid,phi=phi)
ac.coord=tmp$ac.coord
accept1$coord=accept1$coord+tmp$accept
# ac.coord=ac.coord.true
#sample phi
tmp=sample.phi(ac.coord=ac.coord,grid.coord=grid.coord,n.grid=n.grid,
n.ac=n.ac,phi=phi,jump=jump1$phi,dat=dat,z=z)
phi=tmp$phi
accept1$phi=accept1$phi+tmp$accept
# phi=phi.true
#sample z
z=sample.z(ac.coord=ac.coord,grid.coord=grid.coord,phi=phi,
n.grid=n.grid,n.ac=n.ac,n.tsegm=n.tsegm,dat=dat)
# z=z.true
#adapt MH
if (i<nburn & i%%adaptMH==0){
tmp=print.adapt(accept1z=accept1,jump1z=jump1,accept.output=adaptMH)
jump1=tmp$jump1
accept1=tmp$accept1
}
#store results
store.coord[i,]=unlist(ac.coord)
store.z[i,]=z
store.param[i,]=phi
}
tmp=sample.coord(ac.coord=ac.coord,jump=jump1$coord,dat=dat,
grid.coord=grid.coord,z=z,n.ac=n.ac,n.grid=n.grid,phi=phi)
dim(ac.coord)
ac.coord.orig=ac.coord.old=ac.coord
for (i in 1:n.ac){
for (j in 1:2){ #to sample each coordinate separately
ac.coord.new=ac.coord.old
ac.coord.new[i,j]=rnorm(1,mean=ac.coord.old[i,j],sd=jump[i,j])
#get distances
dist1.old=get.distance(ac.coord=ac.coord.old,grid.coord=grid.coord,
n.grid=n.grid,n.ac=n.ac)
dist1.new=get.distance(ac.coord=ac.coord.new,grid.coord=grid.coord,
n.grid=n.grid,n.ac=n.ac)
#get loglikel
pold=get.loglikel(dist1=dist1.old,dat=dat,z=z,n.ac=n.ac,phi=phi,n.grid=n.grid)
pnew=get.loglikel(dist1=dist1.new,dat=dat,z=z,n.ac=n.ac,phi=phi,n.grid=n.grid)
#accept or reject MH
k=acceptMH(p0=pold,p1=pnew,x0=ac.coord.old[i,j],x1=ac.coord.new[i,j],BLOCK=F)
ac.coord.old[i,j]=k$x
}
}
jump=jump1$coord
options(warn=2)
ac.coord.orig=ac.coord.old=ac.coord
for (i in 1:n.ac){
for (j in 1:2){ #to sample each coordinate separately
ac.coord.new=ac.coord.old
ac.coord.new[i,j]=rnorm(1,mean=ac.coord.old[i,j],sd=jump[i,j])
#get distances
dist1.old=get.distance(ac.coord=ac.coord.old,grid.coord=grid.coord,
n.grid=n.grid,n.ac=n.ac)
dist1.new=get.distance(ac.coord=ac.coord.new,grid.coord=grid.coord,
n.grid=n.grid,n.ac=n.ac)
#get loglikel
pold=get.loglikel(dist1=dist1.old,dat=dat,z=z,n.ac=n.ac,phi=phi,n.grid=n.grid)
pnew=get.loglikel(dist1=dist1.new,dat=dat,z=z,n.ac=n.ac,phi=phi,n.grid=n.grid)
#accept or reject MH
k=acceptMH(p0=pold,p1=pnew,x0=ac.coord.old[i,j],x1=ac.coord.new[i,j],BLOCK=F)
ac.coord.old[i,j]=k$x
}
}
i
j
ac.coord.new=ac.coord.old
ac.coord.new[i,j]=rnorm(1,mean=ac.coord.old[i,j],sd=jump[i,j])
#get distances
dist1.old=get.distance(ac.coord=ac.coord.old,grid.coord=grid.coord,
n.grid=n.grid,n.ac=n.ac)
dist1.new=get.distance(ac.coord=ac.coord.new,grid.coord=grid.coord,
n.grid=n.grid,n.ac=n.ac)
pold=get.loglikel(dist1=dist1.old,dat=dat,z=z,n.ac=n.ac,phi=phi,n.grid=n.grid)
pnew=get.loglikel(dist1=dist1.new,dat=dat,z=z,n.ac=n.ac,phi=phi,n.grid=n.grid)
dim(dist1.old)
pold=get.loglikel(dist1=dist1.old,dat=dat,z=z,n.ac=n.ac,phi=phi,n.grid=n.grid)
z
rm(list=ls(all=TRUE))
set.seed(10)
#read important functions
setwd('U:\\GIT_models\\activity_center1')
library('Rcpp')
sourceCpp('aux1.cpp')
source('gibbs sampler.R')
source('gibbs functions.R')
#get data
dat=read.csv('fake data.csv',as.is=T)
grid.coord=read.csv('fake data grid.csv',as.is=T)
#basic setup
ngibbs=1000
nburn=ngibbs/2
n.ac=3
#run gibbs sampler
options(warn=2)
res=gibbs.activity.center(dat=dat,grid.coord=grid.coord,n.ac=n.ac,
ac.coord.init=data.frame(x=runif(n.ac),y=runif(n.ac)))
rm(list=ls(all=TRUE))
set.seed(10)
#read important functions
setwd('U:\\GIT_models\\activity_center1')
library('Rcpp')
sourceCpp('aux1.cpp')
source('gibbs sampler.R')
source('gibbs functions.R')
#get data
dat=read.csv('fake data.csv',as.is=T)
grid.coord=read.csv('fake data grid.csv',as.is=T)
#basic setup
ngibbs=1000
nburn=ngibbs/2
n.ac=3
ac.coord.init=data.frame(x=runif(n.ac,min=0,max=100),
y=runif(n.ac,min=0,max=100))
#run gibbs sampler
options(warn=2)
res=gibbs.activity.center(dat=dat,grid.coord=grid.coord,n.ac=n.ac,
ac.coord.init=ac.coord.init)
set.seed(1)
#basic setup
n.tsegm=100
n.ac=3
n.grid=30
n=floor(runif(n.tsegm,min=0,max=900))
#spatial coordinates
grid.coord=data.frame(x=runif(n.grid,min=0,max=100),
y=runif(n.grid,min=0,max=100))
ac.coord.true=ac.coord=data.frame(x=runif(n.ac,min=0,max=100),
y=runif(n.ac,min=0,max=100))
#cluster membership
z.true=z=sample(1:n.ac,size=n.tsegm,replace=T)
#distance decay parameter
phi.true=phi=0.1
#generate data
y=matrix(NA,n.tsegm,n.grid)
for (i in 1:n.tsegm){
#calculate distance
x2=(grid.coord$x-ac.coord$x[z[i]])^2
y2=(grid.coord$y-ac.coord$y[z[i]])^2
d=sqrt(x2+y2)
#calculate probability
tmp=exp(-phi*d)
prob=tmp/sum(tmp)
#draw results
y[i,]=rmultinom(1,size=n[i],prob=prob)
}
image(y[z==3,])
plot(res$phi,type='l')
abline(h=phi.true,col='red')
k=data.frame(estim=res$z[ngibbs,],true1=z.true)
table(k)
ordem=c(2,1,3)
ac.coord=res$coord[ngibbs,]
ac.coord[ordem,]
ac.coord.true
ordem=c(2,1,3)
ac.coord=matrix(res$coord[ngibbs,],n.ac,2)
ac.coord[ordem,]
ac.coord.true
rm(list=ls(all=TRUE))
set.seed(100)
#read important functions
setwd('U:\\GIT_models\\activity_center1')
library('Rcpp')
sourceCpp('aux1.cpp')
source('gibbs sampler.R')
source('gibbs functions.R')
#get data
dat=read.csv('fake data.csv',as.is=T)
grid.coord=read.csv('fake data grid.csv',as.is=T)
#basic setup
ngibbs=1000
nburn=ngibbs/2
n.ac=3
ac.coord.init=data.frame(x=runif(n.ac,min=0,max=100),
y=runif(n.ac,min=0,max=100))
#run gibbs sampler
options(warn=2)
res=gibbs.activity.center(dat=dat,grid.coord=grid.coord,n.ac=n.ac,
ac.coord.init=ac.coord.init)
rm(list=ls(all=TRUE))
set.seed(100)
#read important functions
setwd('U:\\GIT_models\\activity_center1')
library('Rcpp')
sourceCpp('aux1.cpp')
source('gibbs sampler.R')
source('gibbs functions.R')
#get data
dat=read.csv('fake data.csv',as.is=T)
grid.coord=read.csv('fake data grid.csv',as.is=T)
#basic setup
ngibbs=1000
nburn=ngibbs/2
n.ac=3
ac.coord.init=data.frame(x=runif(n.ac,min=0,max=100),
y=runif(n.ac,min=0,max=100))
#run gibbs sampler
options(warn=2)
res=gibbs.activity.center(dat=dat,grid.coord=grid.coord,n.ac=n.ac,
ac.coord.init=ac.coord.init)
set.seed(1)
#basic setup
n.tsegm=100
n.ac=3
n.grid=30
n=floor(runif(n.tsegm,min=0,max=900))
#spatial coordinates
grid.coord=data.frame(x=runif(n.grid,min=0,max=100),
y=runif(n.grid,min=0,max=100))
ac.coord.true=ac.coord=data.frame(x=runif(n.ac,min=0,max=100),
y=runif(n.ac,min=0,max=100))
#cluster membership
z.true=z=sample(1:n.ac,size=n.tsegm,replace=T)
#distance decay parameter
phi.true=phi=0.1
#generate data
y=matrix(NA,n.tsegm,n.grid)
for (i in 1:n.tsegm){
#calculate distance
x2=(grid.coord$x-ac.coord$x[z[i]])^2
y2=(grid.coord$y-ac.coord$y[z[i]])^2
d=sqrt(x2+y2)
#calculate probability
tmp=exp(-phi*d)
prob=tmp/sum(tmp)
#draw results
y[i,]=rmultinom(1,size=n[i],prob=prob)
}
image(y[z==3,])
plot(res$logl,type='l')
plot(res$phi,type='l')
abline(h=phi.true,col='red')
k=data.frame(estim=res$z[ngibbs,],true1=z.true)
table(k)
ordem=c(2,3,1)
ac.coord=matrix(res$coord[ngibbs,],n.ac,2)
ac.coord[ordem,]
ac.coord.true
set.seed(1)
n.tsegm=100
n.ac=3
n.grid=30
n=floor(runif(n.tsegm,min=0,max=900))
?floor
n=runif(n.tsegm,min=0,max=900)
n
n=floor(runif(n.tsegm,min=0,max=900))
n
n=runif(n.tsegm,min=0,max=900)
n
floor(n)
grid.coord=data.frame(x=runif(n.grid,min=0,max=100),
y=runif(n.grid,min=0,max=100))
ac.coord.true=ac.coord=data.frame(x=runif(n.ac,min=0,max=100),
y=runif(n.ac,min=0,max=100))
ac.coord
z.true=z=sample(1:n.ac,size=n.tsegm,replace=T)
phi.true=phi=0.1
y=matrix(NA,n.tsegm,n.grid)
for (i in 1:n.tsegm){
#calculate distance
x2=(grid.coord$x-ac.coord$x[z[i]])^2
y2=(grid.coord$y-ac.coord$y[z[i]])^2
d=sqrt(x2+y2)
#calculate probability
tmp=exp(-phi*d)
prob=tmp/sum(tmp)
#draw results
y[i,]=rmultinom(1,size=n[i],prob=prob)
}
image(y[z==3,])
image(y[z==2,])
image(y[z==1,])
View(y)
image(y[x==3,])
rm(list=ls(all=TRUE))
set.seed(100)
library('Rcpp')
sourceCpp('aux1.cpp')
source('gibbs sampler.R')
source('gibbs functions.R')
dat=read.csv('fake data.csv',as.is=T)
grid.coord=read.csv('fake data grid.csv',as.is=T)
ngibbs=1000
nburn=ngibbs/2
n.ac=3
ac.coord.init=data.frame(x=runif(n.ac,min=0,max=100),
y=runif(n.ac,min=0,max=100))
options(warn=2)
res=gibbs.activity.center(dat=dat,grid.coord=grid.coord,n.ac=n.ac,
ac.coord.init=ac.coord.init)
plot(res$logl,type='l')
plot(res$phi,type='l')
abline(h=phi.true,col='red')
phi.true=phi=0.1
abline(h=phi.true,col='red')
k=data.frame(estim=res$z[ngibbs,],true1=z.true)
z.true=z=sample(1:n.ac,size=n.tsegm,replace=T)
n.tsegm=100
z.true=z=sample(1:n.ac,size=n.tsegm,replace=T)
k=data.frame(estim=res$z[ngibbs,],true1=z.true)
View(k)
table(k)
ordem=c(2,3,1)
ac.coord=matrix(res$coord[ngibbs,],n.ac,2)
ac.coord[ordem,]
ac.coord.true
ac.coord.true=ac.coord=data.frame(x=runif(n.ac,min=0,max=100),
y=runif(n.ac,min=0,max=100))
ac.coord.true
